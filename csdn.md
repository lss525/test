# **西安邮电大学linux兴趣小组2025纳新题解**
*学长寄语：长期以来，西邮 Linux 兴趣小组的面试题以难度之高名扬西邮校内。我们作为出题人也清楚地知道这份试题略有难度。请你动手敲一敲代码。别担心，若有同学能完成一半的题目，就已经十分优秀。其次，相比于题目的答案，我们对你的思路和过程更感兴趣，或许你的答案略有瑕疵，但你正确的思路和对知识的理解足以为你赢得绝大多数的分数。最后，做题的过程也是学习和成长的过程，相信本试题对你更加熟悉地掌握 C 语言一定有所帮助。祝你好运。我们东区逸夫楼 FZ103 见！* 

本题目只作为西邮 Linux 兴趣小组 2025 纳新面试的有限参考。
为节省版面，本试题的程序源码省去了 ==#include== 指令。
本试题中的程序源码仅用于考察 C 语言基础，不应当作为 C 语言「代码风格」的范例。
所有题目编译并运行于 **x86_64 GNU/Linux**环境。

## 0.拼命的企鹅
一只企鹅在爬山，每隔一段路都会遇到一块石头。第 1 块石头重量是==a==，每往上走一段路，石头重量就会变成上一段的平方。企鹅可以选择把某些石头捡起来，最后把捡到的石头重量相乘。

它怎样捡石头，才能得到重量乘积恰好是 ==a== 的 ==b== 次方的石头？（比如 ==b = 173== 时， 要捡哪些石头？）

### 关键逻辑


#### <ul><li>1. 找到石头重量规律：<p>第 n 块石头的重量是 a^{2^{n-1}}<p>（第1块：a^1=a^{2^0}，第2块：a^2=a^{2^1}，第3块：a^4=a^{2^2}，以此类推）。</li>
#### <ul><li>2. 乘积计算：同底数幂相乘，底不变，指数相加（相当于a² x a<sup>2<sup>2 </sup> </sup> x a<sup>2<sup>3</sup></sup>...)<p>就可以得到指数的和（也就是b）：2<sup>2</sup>+2<sup>3</sup>+2<sup>4</sup>+...+2<sup>n</sup>.<p></li>
#### <ul><li>3. 根据二进制找出石头的位置：（比如b=173,可以得到173=1+4+8+32+128）<p>然后可以利用二进制标记位置:<p>例如：173为10101101,代表要找的石头为：第1、3、4、6、8块。</li>
## 1. 西邮Linux欢迎你啊
*请解释以下代码的运行结果。*
```c
int main() {
      if (printf("Hi guys! ") || printf("Xiyou Linux ")) {
        printf("%d\n", printf("Welcome to Xiyou Linux 2%d", printf("")));
      }
    return 0;
}
```
### 代码分析
<ul><li>1. if语句判断：
<p>由于按位或的“短路性质”（即a||b,先判断a，若a为真则先执行a，b会被短路），所以由于printf函数的返回值为其有效打印字符个数，应此，第一个判断语句的返回值为真，“||”后的语句被短路，只会打印“Hi guys!“</li>

<li>2. printf函数的分析：<p><ul><li>1. 从最内层开始，printf的返回值为0,且不打印字符；<p></li><li>2.第二层的打印为："Welcome to Xiyou Linux 20"，返回值为25； <p><li>3. 第三层的打印为："Welcome to Xiyou Linux 2025“。</li></ul>  

<li>3.最后打印得出的值为：“Hi guys!Welcome to Xiyou Linux 2025“  
</li></ul>  

## 2. 可以和 \0 组一辈子字符串吗？
*你能找到成功打印的语句吗？你能看出每个 if 中函数的返回值吗？这些函数各有什么特点？*
```c
int main() {
    char p1[] = { 'W', 'e', 'l', 'c', 'o', 'm', 'e', '\0' };
    char p2[] = "Join us\0", p4[] = "xiyou_linux_group";
    const char* p3 = "Xiyou Linux Group\0\n2025\0";
    if (strcmp(p1, p2)) {
        printf("%s to %s!\n", p1, p2);
    }
    if (strlen(p3) > sizeof(p3)) {
        printf("%s", p3);
    }
    if (sizeof(p1) == sizeof(p2)) {
        printf("%s", p4);
    }
    return 0;
}
```
### 代码分析： 
 函数分析：
 
 <li>1. strcmp(str1,str2)函数：
 <p><ul><li>(1) . 对比字符串：(返回值）若str1=str2,则返回值为0；
 </li><p><li>(2) . 若str1的ascll值大于str2,返回值为正数，反之返回值为负数。
 </ul><p><li>2. strlen()函数：
 <p><ul><li>用于计算有效字符的个数，计算到“\0”处停止（不包括“\0”）。
 
 </li></ul>  
 sizeof()与strlen()的比较：  
<ul><li>(1) . sizeof()是关键字，用于计算变量或类型所占字节个数大小。<p><li>(2) . sizeof()计算的是整个字符串所占字将节的大小（包括“\0”）。</ul>运行过程：<p><li>1. 第一个if语句判断：<p><ul><li>
 由于strcmp()函数运行，p1字符串与p2字符串进行比较，根据程序可得：p1字符串与p2字符串不相等，所以strcmp()函数的返回值为非零整数。因此，if()判断里面为真（0为假非0为真），得到printf函数打印为：“Welcome to Join us!"；<p></ul><li>2. 第二个if语句判断：<p><ul><li>strlen(p3)得出的大小为16，而在sizeof()的计算中，p3的类型为char*（字符串指针变量），所以sizeof()所计算的是指针类型的大小而不是字符串的大小，sizeof()计算得出的结果为4（32位为4,64位为8）。因此if内语句判断为真，得出的打印值为“Xiyou Linux Group“（"\0"为终止字符，printf碰到后会终止打印）；</ul><p><li>3. 第三个if判断语句：<p><ul><li>从表面上看，p1与p2的字符个数都相等，但是，当直接定义一个字符串时，c语言语法会自动在结尾处补种植字符“\0”，所以sizeof()计算后的p1,p2分别为8,9，因此if语句判断结果为假，不会执行if下的命令，p4不会进行打印。</ul>得出结果：    
   
   - Welcome to Join us!  
   Xiyou Linux Group  </ul>

## 3. 数学没问题，浮点数有鬼  
*这个程序的输出是什么？解释为什么会这样？*  
```c  
int main() {
    float a1 = 0.3, b1 = 6e-1, sum1 = 0.9;
    printf("a1 + b1 %s sum1\n", (a1 + b1 == sum1) ? "==" : "!=");
    float a2 = 0x0.3p0, b2 = 0x6p-4, sum2 = 0x0.9p0;
    printf("a2 + b2 %s sum2\n", (a2 + b2 == sum2) ? "==" : "!=");
    return 0;
}  
```
### 代码分析 ：  
- 1 . **float**：   

  - 变为浮点型的关键字,可以定义一个浮点型变量，由于计算机对数据的保存以二进制为标准，所以对于有些浮点型的数无法精确保存，例如：0.3在内存中保存为0.01001100110011...这样的无限循环小数。    

- 2 . 三目操作符（ ？ ： ）：    

  - 运行原理为：如果前置的条件为真，则执行“？”后的语句，若为假，则执行“：”后的语句。   

- 3 . 运行过程：   

  - （1）. 由于a1,b1,sum1的类型为float浮点型，所以在计算机中无法精确储存，应此，a1+b1=sum1的结果为假，三目操作符的运行为“！=”，因此第一个打印为：a1 + b1 ！=sum1。  

  - （2) . 因为a2,b2,sum2,的书面表示为十六进制，2<sup>4</sup>为16,所以十六进制的浮点类型可以在二进制中精确保存，最后得出的打印结果为：a2 + b2 == sum2。  
    
## 4. 不合群的数字  
*在一个数组中，所有数字都出现了偶数次，只有两个数字出现了奇数次，请聪明的你帮我看看以下的代码是如何找到这两个数字的呢？*  
```c  
void findUndercoverIDs(int nums[], int size) {
    int xorAll = 0,id_a = 0,id_b = 0;
    for (int i = 0; i < size; i++) {
        xorAll ^= nums[i];
    }
    int diffBit = xorAll & -xorAll;
    for (int i = 0; i < size; i++) {
        if(nums[i] & diffBit){
            id_a ^= nums[i];
        } else {
            id_b ^= nums[i];
        }
    }
    printf("These nums are %d %d\n", id_a, id_b);
}  
```
### 代码分析：  
  - 1  .  "**^**"操作符：    

    - 它的规则是：比较两个二进制数的每一位，如果相同则结果为 0，如果不同则结果为 1。若一个数与本身自己异或，结果都为 0。  
        

- 2  . **xorall**：  
  - for循环中的**xorall**利用了“^”的交换律，将相同的数进行按位异或处理，最终得出的结果为两个单独出现数字的异或值。    

- 3 . **difBit**：  
  - **difBit**利用 **xorAll & -xorAll** 找出两个数字的最右侧的不同位。  
- 然后进入for循环：  
  - 利用if语句区分两个单独出现的数（注意：若不进行区分，则最后得出的结果还是两个数的异或值）最后利用异或的特点进行查找，打印出那两个数；  
    
## 5. 会一直循环吗？  
*你了解 argc 和 argv 吗，程序的输出是什么？为什么会这样？*
```c  
int main(int argc, char* argv[]) {
    printf("argc = %d\n", argc);
    while (argc++ > 0) {
        if(argc < 0){
            printf("argv[0] %s\n", argv[0]);
            break;
        }
    }
    printf("argc = %d\n", argc);
    return 0;
}  
```
### argc 和 argv：  
- 1 .首先**argc**和 **argv**。它们是 C语言 程序中 main 函数的参数，用于接收命令行参数。  

- 2 .**argc**的类型为整数，表示命令行参数的数量，在未初始化时通常被赋值为1，而**argv**是字符指针数组，存储每个命令行参数的字符串，其中**argv**[0]为字符串首元素，往往表示该程序的文件名，**argv**[1] 到 **argv**[**argc-1**] 是我们输入的参数。  
- 3 .命令行：   
  - 是一种通过文本命令与计算机操作系统交互的界面。我们通过输入特定的文本指令来执行操作。  
### 代码分析：    

- 1 . **argc**开始时为1,然后进入**while**中不断循环，直到超出**int**类型范围，为-2147483648时跳出循环并进行打印。    

- 2 . 但是由于终端的确认操作，会默认打印我们所提出的指令，应此会打印当前程序的文件名。  
    
- 3 .最后得出结果为：  <ol> “当前程序的文件名“<p>"-2147483648"</ol>  
## 6. const 与指针：谁能动，谁不能动？  
```c  
struct P {
    int x;
    const int y;
};

int main() {
    struct P p1 = { 10, 20 }, p2 = { 30, 40 };
    const struct P p3 = { 50, 60 };
    struct P* const ptr1 = &p1;
    const struct P* ptr2 = &p2;
    const struct P* const ptr3 = &p3;
    return 0;
}  
```
说说下列操作是否合法，并解释原因：

ptr1->x = 100, ptr2->x = 300, ptr3->x = 500

ptr1->y = 200, ptr1 = &p2, ptr2->y = 400

ptr2 = &p1, ptr3->y = 600, ptr3 = &p1

### const：
- 用于声明常量的关键字，简单来说，const 是创建常量的一个工具。   

- 特点：  
  - 必须初始化：声明时必须同时赋值。

  - 不可重新赋值：声明后，不能再给这个标识符赋予一个新的值。
    
### 代码分析：  
- 1 . 由于结构体中y被**const**修饰，所以y值无法被修改。  
- 2 . 主函数main中，结构体定义了一个p指针，然后分别给结构体**p1,p2,p3**赋值。  
- 3 . 具体步骤分析：  
  - 第一步**const**修饰指针不修饰结构体，使它无法修改指向的地址，但可以修改其所指向的结构体；  
  - 第二步**const**修饰结构体不修饰指针，使他所指向的结构体无法被修改，但可以修改指向的地址；  
  - 第三步**const**将二者同时修饰，使得他既无法修改指向的地址，也无法修改他所指向的结构体。   

- 4 . 最后可以得出答案：  
  - ptr1->x = 100 修改合法；  
  - ptr2 = &p1 修改合法；
  - 其余修改均不合法。  
    

## 7. 指针！数组!  
*在主函数中定义如下变量:*  
```c  
int main() {
    int a[3] = { 2, 4, 8 };
    int(*b)[3] = &a;
    int* c[3] = { a, a + 1, a + 2 };
    int (*f1(int))(int*, int);
    return 0;
}  
```
说说这几个表达式的输出分别是什么？

a, *b, *b + 1, b, b + 1, * (*b + 1), c, sizeof(a), sizeof(b), sizeof(&a), sizeof(f1)


